#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# GUI module generated by PAGE version 5.0.3
#  in conjunction with Tcl version 8.6

import sys
import platform
import tkinter as tk
import tkinter.ttk as ttk
from tkinter import messagebox
import datetime
import os
import glob
from threading import Thread
from gui import gui_support
from mlit import result_page
from mlit import data_page
from mlit import station_page
from mlit import station
from mlit import combobox_selections


def vp_start_gui():
    '''Starting point when module is the main routine.'''
    global val, w, root
    root = tk.Tk()
    gui_support.set_Tk_var()
    top = Toplevel1(root)
    gui_support.init(root, top)
    root.mainloop()


w = None


def create_Toplevel1(rt, *args, **kwargs):
    '''Starting point when module is imported by another module.
       Correct form of call: 'create_Toplevel1(root, *args, **kwargs)' .'''
    global w, w_win, root
    # rt = root
    root = rt
    w = tk.Toplevel(root)
    gui_support.set_Tk_var()
    top = Toplevel1(w)
    gui_support.init(w, top, *args, **kwargs)
    return (w, top)


def destroy_Toplevel1():
    global w
    w.destroy()
    w = None


class Toplevel1:
    def __init__(self, top=None):
        """This class configures and populates the toplevel window.
           top is the toplevel containing window."""
        _bgcolor = '#d9d9d9'  # X11 color: 'gray85'
        _fgcolor = '#000000'  # X11 color: 'black'
        _compcolor = '#d9d9d9'  # X11 color: 'gray85'
        _ana1color = '#d9d9d9'  # X11 color: 'gray85'
        _ana2color = '#ececec'  # Closest X11 color: 'gray92'
        self.style = ttk.Style()
        if sys.platform == "win32":
            self.style.theme_use('winnative')
        self.style.configure('.', background=_bgcolor)
        self.style.configure('.', foreground=_fgcolor)
        self.style.configure('.', font="TkDefaultFont")
        self.style.map('.', background=[('selected', _compcolor), ('active', _ana2color)])

        self._date_edit_mode = "normal"
        today_str = datetime.datetime.strftime(datetime.datetime.now(), "%Y%m%d")
        self._start_date_str = tk.StringVar(value=today_str)
        self._end_date_str = tk.StringVar(value=today_str)

        top.geometry("640x200+587+365")
        top.resizable(0, 0)
        top.title("国土交通省　水文水質データベース")
        top.configure(background="#d9d9d9")
        top.configure(highlightbackground="#d9d9d9")
        top.configure(highlightcolor="black")

        self.label_item = tk.Label(top)
        self.label_item.place(relx=0.017, rely=0.055, height=21, width=58)
        self.label_item.configure(activebackground="#f9f9f9")
        self.label_item.configure(activeforeground="black")
        self.label_item.configure(background="#d9d9d9")
        self.label_item.configure(disabledforeground="#a3a3a3")
        self.label_item.configure(foreground="#000000")
        self.label_item.configure(highlightbackground="#d9d9d9")
        self.label_item.configure(highlightcolor="black")
        self.label_item.configure(text='''観測項目''')

        self.label_basin = tk.Label(top)
        self.label_basin.place(relx=0.017, rely=0.22, height=21, width=45)
        self.label_basin.configure(activebackground="#f9f9f9")
        self.label_basin.configure(activeforeground="black")
        self.label_basin.configure(background="#d9d9d9")
        self.label_basin.configure(disabledforeground="#a3a3a3")
        self.label_basin.configure(foreground="#000000")
        self.label_basin.configure(highlightbackground="#d9d9d9")
        self.label_basin.configure(highlightcolor="black")
        self.label_basin.configure(text='''水系名''')

        self.label_prefectures = tk.Label(top)
        self.label_prefectures.place(relx=0.017, rely=0.384, height=21, width=58)

        self.label_prefectures.configure(activebackground="#f9f9f9")
        self.label_prefectures.configure(activeforeground="black")
        self.label_prefectures.configure(background="#d9d9d9")
        self.label_prefectures.configure(disabledforeground="#a3a3a3")
        self.label_prefectures.configure(foreground="#000000")
        self.label_prefectures.configure(highlightbackground="#d9d9d9")
        self.label_prefectures.configure(highlightcolor="black")
        self.label_prefectures.configure(text='''都道府県''')

        self.combobox_item = ttk.Combobox(top)
        self.combobox_item.place(relx=0.117, rely=0.055, relheight=0.128
                                 , relwidth=0.272)
        self.combobox_item.configure(values=list(combobox_selections.ITEMS.values()))
        self.combobox_item.current(0)

        self.combobox_basin = ttk.Combobox(top)
        self.combobox_basin.place(relx=0.117, rely=0.22, relheight=0.128, relwidth=0.272)
        self.combobox_basin.configure(takefocus="")
        self.combobox_basin.configure(values=list(combobox_selections.BASINS.values()), state="readonly")
        self.combobox_basin.current(0)

        self.combobox_prefectures = ttk.Combobox(top)
        self.combobox_prefectures.place(relx=0.117, rely=0.384, relheight=0.128, relwidth=0.272)
        self.combobox_prefectures.configure(takefocus="")
        self.combobox_prefectures.configure(values=list(combobox_selections.PREFECTURES.values()))
        self.combobox_prefectures.current(0)

        self.TSeparator1 = ttk.Separator(top)
        self.TSeparator1.place(relx=0.017, rely=0.549, relwidth=0.967)

        self.listbox_result = ScrolledListBox(top)
        self.listbox_result.place(relx=0.6, rely=0.055, relheight=0.445
                                  , relwidth=0.384)
        self.listbox_result.configure(background="white")
        # self.listbox_result.configure(cursor="xterm")
        self.listbox_result.configure(disabledforeground="#a3a3a3")
        self.listbox_result.configure(font="TkFixedFont")
        self.listbox_result.configure(foreground="black")
        self.listbox_result.configure(highlightbackground="#d9d9d9")
        self.listbox_result.configure(highlightcolor="#d9d9d9")
        self.listbox_result.configure(selectmode="extended")

        self.button_search = ttk.Button(top)
        self.button_search.place(relx=0.43, rely=0.183, relwidth=0.131, relheight=0.2)
        self.button_search.configure(takefocus="")
        self.button_search.configure(text='''検　索''')

        self.style.map('TRadiobutton', background=[('selected', _bgcolor), ('active', _ana2color)])
        self.radiobutton_hour = ttk.Radiobutton(top)
        self.radiobutton_hour.place(relx=0.031, rely=0.61, relwidth=0.131
                                    , relheight=0.0, height=23)
        self.radiobutton_hour.configure(variable=gui_support.kind_selected, value=1)
        self.radiobutton_hour.configure(text='''1時間間隔''')

        self.radiobutton_realtime = ttk.Radiobutton(top)
        self.radiobutton_realtime.place(relx=0.031, rely=0.793, relwidth=0.163
                                        , relheight=0.0, height=23)
        self.radiobutton_realtime.configure(variable=gui_support.kind_selected, value=9)
        self.radiobutton_realtime.configure(text='''リアルタイム''')

        self.label_start = tk.Label(top)
        self.label_start.place(relx=0.25, rely=0.615, height=23, width=54)
        self.label_start.configure(activebackground="#f9f9f9")
        self.label_start.configure(activeforeground="black")
        self.label_start.configure(background="#d9d9d9")
        self.label_start.configure(disabledforeground="#a3a3a3")
        self.label_start.configure(foreground="#000000")
        self.label_start.configure(highlightbackground="#d9d9d9")
        self.label_start.configure(highlightcolor="black")
        self.label_start.configure(text='''開始日付''')

        self.label_end = tk.Label(top)
        self.label_end.place(relx=0.25, rely=0.795, height=23, width=54)
        self.label_end.configure(activebackground="#f9f9f9")
        self.label_end.configure(activeforeground="black")
        self.label_end.configure(background="#d9d9d9")
        self.label_end.configure(disabledforeground="#a3a3a3")
        self.label_end.configure(foreground="#000000")
        self.label_end.configure(highlightbackground="#d9d9d9")
        self.label_end.configure(highlightcolor="black")
        self.label_end.configure(text='''終了日付''')

        self.entry_start_date = tk.Entry(top, textvariable=self._start_date_str)
        self.entry_start_date.place(relx=0.34, rely=0.61, relheight=0.128, relwidth=0.1)

        self.entry_end_date = tk.Entry(top, textvariable=self._end_date_str)
        self.entry_end_date.place(relx=0.34, rely=0.793, relheight=0.128, relwidth=0.1)

        self.button_output_selected = ttk.Button(top)
        self.button_output_selected.place(relx=0.52, rely=0.6, relheight=0.15, relwidth=0.22)
        self.button_output_selected.configure(takefocus="")
        self.button_output_selected.configure(text='''選択した観測所を出力''')

        self.button_output_all = ttk.Button(top)
        self.button_output_all.place(relx=0.76, rely=0.6, relheight=0.15, relwidth=0.22)
        self.button_output_all.configure(takefocus="")
        self.button_output_all.configure(text='''全観測所を出力''')

        self._set_button_actions()

        self.process_bar = ttk.Progressbar(top)
        self.process_bar.place(relx=0.53, rely=0.8, relheight=0.12, relwidth=0.44)

    def _set_button_actions(self):
        self.button_search.configure(command=self._search_button_action)
        self.button_output_selected.configure(command=self._output_selected_button_action)
        self.button_output_all.configure(command=self._output_all_button_action)
        self.radiobutton_hour.configure(command=self._radiobutton_action)
        self.radiobutton_realtime.configure(command=self._radiobutton_action)

    def _search_button_action(self):
        admit = True
        if self.combobox_basin.get() == "全水系":
            if self.combobox_prefectures.get() == "全国":
                admit = messagebox.askokcancel("検索", "全国の全水系で検索することは推奨しません\n所要時間が非常に長くなります\n本当に検索を行いますか？")
            else:
                admit = messagebox.askokcancel("検索", "全水系で検索を行いますか？\n所要時間が長くなります")
        if admit:
            item_text = self.combobox_item.get()
            item_no = combobox_selections.ITEMS_NOS[item_text]
            basin_text = self.combobox_basin.get()
            basin_no = combobox_selections.BASIN_NOS[basin_text]
            prefecture_text = self.combobox_prefectures.get()
            prefecture_no = combobox_selections.PREFECTURES_NOS[prefecture_text]
            self._result_page = result_page.MLITResultPage(item=item_no, basin=basin_no, prefecture=prefecture_no)
            list_box_variable = tk.StringVar(value=list(self._result_page.station_dict.keys()))
            self.listbox_result.configure(listvariable=list_box_variable)

    def _radiobutton_action(self):
        kind = gui_support.kind_selected.get()
        if kind == 1:
            self._date_edit_mode = "normal"
        if kind == 9:
            self._date_edit_mode = "disabled"
        self._refresh_date_entry()

    def _refresh_date_entry(self):
        self.entry_start_date.configure(state=self._date_edit_mode)
        self.entry_end_date.configure(state=self._date_edit_mode)

    def _check_date(self):
        start_date = datetime.datetime.strptime(self._start_date_str.get(), "%Y%m%d")
        end_date = datetime.datetime.strptime(self._end_date_str.get(), "%Y%m%d")
        if (end_date - start_date).days > 31:
            messagebox.showerror(title="日付エラー", message="最大31日まで指定してください")
            return 1
        elif (end_date - start_date).days < 0:
            messagebox.showerror(title="日付エラー", message="日付を確認ください")
            return 1
        else:
            return 0

    def _output_selected_button_action(self):
        if not self._check_date():
            _init_output()
            names = [self.listbox_result.get(idx) for idx in self.listbox_result.curselection()]
            self._process_in_new_thread(names)

    def _output_all_button_action(self):
        if not self._check_date():
            _init_output()
            names = self.listbox_result.get(0, tk.END)
            self._process_in_new_thread(names)

    def _process_in_new_thread(self, names):
        self.process_bar.configure(value=0, maximum=len(names))
        t = Thread(target=self._out_put_by_station_names, args=(names,))
        t.start()

    def _out_put_by_station_names(self, names):
        self._disable_buttons()
        for name in names:
            station_id = self._result_page.station_dict[name]
            page = station_page.StationPage(station_id)
            page.station.get_data(kind=gui_support.kind_selected.get(),
                                  start_date=self._start_date_str.get(),
                                  end_date=self._end_date_str.get())

            page.station.output()
            self.process_bar.step()
        if len(names):
            messagebox.showinfo("出力完了", "出力は完了しました！")
        self._enable_buttons()

    def _disable_buttons(self):
        self.button_output_selected.configure(state="disabled")
        self.button_output_all.configure(state="disabled")
        self.button_search.configure(state="disabled")

    def _enable_buttons(self):
        self.button_output_selected.configure(state="normal")
        self.button_output_all.configure(state="normal")
        self.button_search.configure(state="normal")


def _init_output():

    files = glob.glob("output/水位流量/*")
    for f in files:
        os.remove(f)
    files = glob.glob("output/雨量/*")
    for f in files:
        os.remove(f)

    info_out_put_filename = "output/観測所情報/水位流量観測所.csv"
    with open(info_out_put_filename, "w") as file:
        file.write("id,観測所名,経度,緯度,水系,河川,T.P.(m)\n")
    info_out_put_filename = "output/観測所情報/雨量観測所.csv"
    with open(info_out_put_filename, "w") as file:
        file.write("id,観測所名,経度,緯度,水系,河川\n")


# The following code is added to facilitate the Scrolled widgets you specified.
class AutoScroll(object):
    '''Configure the scrollbars for a widget.'''

    def __init__(self, master):
        #  Rozen. Added the try-except clauses so that this class
        #  could be used for scrolled entry widget for which vertical
        #  scrolling is not supported. 5/7/14.
        try:
            vsb = ttk.Scrollbar(master, orient='vertical', command=self.yview)
        except:
            pass
        hsb = ttk.Scrollbar(master, orient='horizontal', command=self.xview)
        try:
            self.configure(yscrollcommand=self._autoscroll(vsb))
        except:
            pass
        self.configure(xscrollcommand=self._autoscroll(hsb))
        self.grid(column=0, row=0, sticky='nsew')
        try:
            vsb.grid(column=1, row=0, sticky='ns')
        except:
            pass
        hsb.grid(column=0, row=1, sticky='ew')
        master.grid_columnconfigure(0, weight=1)
        master.grid_rowconfigure(0, weight=1)
        # Copy geometry methods of master  (taken from ScrolledText.py)
        methods = tk.Pack.__dict__.keys() | tk.Grid.__dict__.keys() \
                      | tk.Place.__dict__.keys()

        for meth in methods:
            if meth[0] != '_' and meth not in ('config', 'configure'):
                setattr(self, meth, getattr(master, meth))

    @staticmethod
    def _autoscroll(sbar):
        '''Hide and show scrollbar as needed.'''

        def wrapped(first, last):
            first, last = float(first), float(last)
            if first <= 0 and last >= 1:
                sbar.grid_remove()
            else:
                sbar.grid()
            sbar.set(first, last)

        return wrapped

    def __str__(self):
        return str(self.master)


def _create_container(func):
    '''Creates a ttk Frame with a given master, and use this new frame to
    place the scrollbars and the widget.'''

    def wrapped(cls, master, **kw):
        container = ttk.Frame(master)
        container.bind('<Enter>', lambda e: _bound_to_mousewheel(e, container))
        container.bind('<Leave>', lambda e: _unbound_to_mousewheel(e, container))
        return func(cls, container, **kw)

    return wrapped


class ScrolledListBox(AutoScroll, tk.Listbox):
    '''A standard Tkinter Listbox widget with scrollbars that will
    automatically show/hide as needed.'''

    @_create_container
    def __init__(self, master, **kw):
        tk.Listbox.__init__(self, master, **kw)
        AutoScroll.__init__(self, master)

    def size_(self):
        sz = tk.Listbox.size(self)
        return sz


def _bound_to_mousewheel(event, widget):
    child = widget.winfo_children()[0]
    if platform.system() == 'Windows' or platform.system() == 'Darwin':
        child.bind_all('<MouseWheel>', lambda e: _on_mousewheel(e, child))
        child.bind_all('<Shift-MouseWheel>', lambda e: _on_shiftmouse(e, child))
    else:
        child.bind_all('<Button-4>', lambda e: _on_mousewheel(e, child))
        child.bind_all('<Button-5>', lambda e: _on_mousewheel(e, child))
        child.bind_all('<Shift-Button-4>', lambda e: _on_shiftmouse(e, child))
        child.bind_all('<Shift-Button-5>', lambda e: _on_shiftmouse(e, child))


def _unbound_to_mousewheel(event, widget):
    if platform.system() == 'Windows' or platform.system() == 'Darwin':
        widget.unbind_all('<MouseWheel>')
        widget.unbind_all('<Shift-MouseWheel>')
    else:
        widget.unbind_all('<Button-4>')
        widget.unbind_all('<Button-5>')
        widget.unbind_all('<Shift-Button-4>')
        widget.unbind_all('<Shift-Button-5>')


def _on_mousewheel(event, widget):
    if platform.system() == 'Windows':
        widget.yview_scroll(-1 * int(event.delta / 120), 'units')
    elif platform.system() == 'Darwin':
        widget.yview_scroll(-1 * int(event.delta), 'units')
    else:
        if event.num == 4:
            widget.yview_scroll(-1, 'units')
        elif event.num == 5:
            widget.yview_scroll(1, 'units')


def _on_shiftmouse(event, widget):
    if platform.system() == 'Windows':
        widget.xview_scroll(-1 * int(event.delta / 120), 'units')
    elif platform.system() == 'Darwin':
        widget.xview_scroll(-1 * int(event.delta), 'units')
    else:
        if event.num == 4:
            widget.xview_scroll(-1, 'units')
        elif event.num == 5:
            widget.xview_scroll(1, 'units')


if __name__ == '__main__':
    vp_start_gui()
